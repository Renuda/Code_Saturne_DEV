#!/bin/sh
########################################################################
# Exemple de fichier de lancement Code_Saturne Version 1.1.1  
#
#              sur station de travail
#
#
#                                              EDF copyright 1999 - 2003
#
########################################################################
########################################################################
#
#
# Cartes a renseigner pour le cluster uniquement 
#        : rubrique utilisateur
#
#    nodes= nombre de "noeuds" a reserver sur le cluster
#    ppn  = nombre de processeurs par noeud (1 ou 2)
#       Attention, le nombre total de processeurs sur lesquels 
#       sera distribue le calcul doit etre donne plus bas dans 
#       la variable NOMBRE_DE_PROCESSEURS (generalement nodes*ppn)
# 
#    cput = cpu time (heures, minutes, secondes)
#
#    mem  = memoire
#           Pour determiner la place memoire a reserver, on peut utiliser 
#           la relation approximative suivante : 
#                    N = (LONGIA*4 + LONGRA*8) / 1000000 
#           qui donne N, place memoire a reserver en Mb 
#
#
#PBS -l nodes=4:ppn=2,cput=1:00:00,mem=320mb
#PBS -j eo -N herculediph
#
#
#
# Definition du cas 
#        : rubrique utilisateur
#
#                    -------------------------------
#
#     L'utilisateur peut avoir a modifier la taille des tableaux 
#       d'entiers et de reels ici : LONGIA et LONGRA respectivement
#     Le nombre d'entiers LONGIA et le nombre de reels LONGRA 
#       dependent des options de calcul, du type d'elements, 
#       des caracteristiques du maillage (2d, 3d, hybride, 
#       non conforme ...) et du nombre de variables, par exemple.
#       En k-epsilon, si on note NCEL le nombre de cellules du 
#       maillage, on peut la plupart du temps utiliser la majoration 
#       grossiere suivante : LONGIA =  45*NCEL et LONGRA = 220*NCEL
#       En Rij-epsilon, une majoration de 20% pourra etre appliquee.
#       Ces valeurs sont relativement elevees pour prendre en compte
#       les maillages 2D qui comprennent de nombreuses faces de bord :
#       une formule plus precise mais plus complexe serait necessaire.
#       Pour les gros cas 3D, une estimation plus precise est donnee 
#       par : LONGIA =  25*NCEL et LONGRA = 120*NCEL.
#
#
#                    -------------------------------
#
#     L'utilisateur peut souhaiter ne pas utiliser l'enveloppe 
#       (maillages *tlc *slc) : positionner IFOENV=0
#     dans les autres cas positionner IFOENV=1 en standard
#
#
#                    -------------------------------
#
#     Pour recoller des maillages, on donne des options supplementaires
#       a l'enveloppe : 
#        - preciser le nom des maillages entre " " dans 
#          la variable MAILLAGE
#        - preciser les options de recollement dans la variable 
#          COMMANDE_RC. Il est preferable de preciser la couleur 
#          des faces a recoller. Si c'est impossible, 
#          il faut omettre l'option -couleur (mais le cout sera 
#          superieur et la robustesse parfois moindre).La selection
#          des faces peut se faire par d'autres moyens que la couleur
#          (voir l'aide de l'enveloppe par ecs -h). 
#       Dans l'exemple ci-dessous, on cherche a recoller 
#         les faces de couleur 3, 4 et 6 des maillages geomet.slc 
#         et toto.unv.
#
#         MAILLAGE="geomet.slc toto.unv"
#         COMMANDE_RC="-rc -couleur 3 4 6"
#
#       S'il n'y a rien a recoller, on peut laisser vide 
#         la variable COMMANDE_RC, soit COMMANDE_RC=.
#
#
#                    -------------------------------
#
#     Pour decouper en triangles les faces dont la distorsion (warp) est 
#       superieure a un angle alpha en degres, on renseigne la variable 
#       COMMANDE_DF. Par exemple, pour decouper au dela d'un angle de 0.01
#       degres (c'est la valeur par defaut) : 
#
#         COMMANDE_DF="-df 0.01"
#
#       Si l'on ne souhaite rien decouper (par defaut), c'est-a-dire si 
#         l'on souhaite utiliser le maillage tel qu'il a ete fourni par le 
#         mailleur, on laisse vide la variable COMMANDE_DF soit COMMANDE_DF=
#
#
#                    -------------------------------
#
#     Pour traiter un cas periodique, il faut renseigner la variable 
#       COMMANDE_PERIO pour l'enveloppe en precisant l'option -perio :
#
#       Deux types de periodicite sont possibles : translation et rotation :
#         Translation : -perio -trans tx ty tz 
#           (tx,ty,tz): composantes du vecteur translation
#         Rotation    : deux possibilites 
#           - donnee de angle, direction et point invariant :
#             -perio -rota -angle a -dir dx dy dz -ptinv px py pz  
#               a         : angle en degres (entre -180 et + 180)
#               (dx,dy,dz): composantes d'un vecteur directeur 
#                             de l'axe de rotation  
#               (px,py,pz): composantes du point invariant de la rotation
#           - donnee de matrice et point invariant :
#             -perio -rota -matrice m11 m12 m13 m21 m22 m23 m31 m32 m33 -ptinv px py pz  
#               mij       : elements de la matrice de rotation par ligne
#               (px,py,pz): composantes du point invariant de la rotation
#
#       On peut composer translation et rotation : 
#             -perio -trans tx ty tz -rota -angle a 
#                                          -dir dx dy dz -ptinv px py pz  
#          ou -perio -trans tx ty tz -rota -matrice m11 m12 m13 
#                                                   m21 m22 m23 
#                                                   m31 m32 m33 
#                                          -ptinv   px py pz   
#         La transformation composite est alors RoT (quel que soit l'ordre 
#           dans lequel apparaissent rotation et translation dans la ligne 
#           de commande).
#
#       Le sens de la periodicite n'a pas d'importance (mais, dans le cas 
#         d'une transformation composee RoT, R et T doivent naturellement
#         etre coherentes entre elles).
#
#       Il est preferable de preciser les faces concernees, en utilisant 
#         les proprietes des faces, par exemple avec l'option -couleur (la 
#         selection des faces peut se faire par d'autres moyens que la 
#         couleur : voir l'aide de l'enveloppe par ecs -h) : par exemple
#           -perio -trans 10 0 0 -couleur 1 2
#
#       On peut imposer jusqu'a trois periodicites (une par direction 
#         d'espace) : on repete pour cela l'option -perio. par exemple 
#         -perio -trans 10 0 0 -perio -trans 0 1 0 -perio -trans 0 0 1
#
#       S'il n'y a pas de periodicite, on doit laisser vide 
#         la variable COMMANDE_PERIO, c'est-a-dire : COMMANDE_PERIO=
#
#       Exemple (le \ marque la continuation de la ligne de commande)
#         COMMANDE_PERIO="-perio -trans -10.2 0 0 -couleur 2             \
#                         -perio -rota -angle 90 -dir 0 0 1 -ptinv 0 0 0 \
#                                -couleur 3 4                            \
#                         -perio -trans 0 1 0                            \ 
#                                -rota -matrice 1 0  0                   \
#                                               0 0 -1                   \
#                                               0 1  0 -ptinv 0 0 -0.2   "
#
#
#                    -------------------------------
#
#     Pour le couplage avec SYRTHES 3.3 (un seul calcul fluide 
#         et un seul calcul solide) il suffit de renseigner
#         la variable COMMANDE_SYRTHES. S'il n'y a pas de couplage
#         il suffit de la laisser vide.
#       Dans l'exemple ci-dessous, on cherche a coupler les faces 
#         de bord fluide de couleur 2 et 3
#
#         COMMANDE_SYRTHES="-syrthes -couleur 2 3"
#
#       Pour des couplages plus complexes, le script devra etre adapte. 
#       Les options de compilation et de lien avec SYRTHES
#         ne sont pas renseignees pour toutes les architectures. 
#
#
#                    -------------------------------
#
#     Le nom d'un eventuel fichier de donnees thermochimie peut etre 
#         fourni dans DONNEES_THERMOCHIMIE. Par exemple : 
#           DONNEES_THERMOCHIMIE="dp_FCP"
#
#
#                    -------------------------------
#
#     Le nom de fichiers de donnees utilisateur supplementaires a utiliser 
#	    peut etre fourni dans FICHIERS_DONNEES_UTILISATEUR
#         Ces fichiers sont supposes etre dans le repertoire DATA
#
#
#                    -------------------------------
#
#     Le nom de fichiers resultats utilisateur supplementaires a rapatrier 
#	    peut etre fourni dans FICHIERS_RESULTATS_UTILISATEUR
#
#
#                    -------------------------------
#
#     L'option NOMBRE_DE_PROCESSEURS donne en parallele, le nombre de
#         procs a utiliser (>1). 
#
#
#     Si l'on souhaite specifier des machines distantes, on peut completer  
#           la chaine optionnelle LISTE_PROCESSEURS. 
#         Ce n'est pas recommande car les performances du reseau sont 
#           generalement tres mauvaises.
#         Deux exemples simples :
#         LISTE_PROCESSEURS="machine1 cpu=nb_cpu1 user=userid1 & machine2 cpu=nb_cpu2 user=userid2")
#         LISTE_PROCESSEURS="machine1  & machine2")
#         Le & separe deux machines. Les champs sont les suivants : 
#           machine1 et machine2 designent le nom des machines 
#              (second champ obtenu par la commande uname -a) 
#              par exemple : chi80xx.der.edf.fr 
#           nb_cpu1 et nb_cpu2 designent le nombre de processeurs des 
#              machines machine1 et machine2 
#              par exemple, sur un pc biprocesseur : cpu=2 
#           userid1 et userid2 designent le login de l'utilisateur sur les
#              machines machine1 et machine2 
#         Les informations cpu= et user= sont optionnelles.  
#         La machine courante (celle depuis laquelle est execute le script)
#           sera obligatoirement utilisee. 
#         Les machines selectionnees doivent etre en nfs et de la meme 
#           architecture (toutes HP ou toutes IRIX, toutes Linux...).
# 
#
#                    -------------------------------
#
#     Les options OPTIMISATION et LISTE_LIBRAIRIES suivantes sont 
#         des options plus avancees, a usage des developpeurs.
#
#       OPTIMISATION permet de specifier l'optimisation selectionnee 
#         (LO, DBG, EM, EF, PROF, PUR...). Par defaut, les choix
#         standards de Code_saturne sont utilises. Ce parametre est 
#         surtout utile en developpement pour utiliser les bibliotheques
#         sans optimisation, en debug, etc. Il est donc conseille de 
#         conserver la valeur par defaut (chaine vide).
#         Ce mot cle est ignore si LISTE_LIBRAIRIES n'est pas vide.
#         Une liste des valeurs d'OPTIMISATION et une explication est
#         fournie par makehelp (voir OPT=).
#
#       LISTE_LIBRAIRIES permet de specifier la liste exhaustive des 
#         bibliotheques de Code_saturne a utiliser lors de l'edition des
#         liens. Par defaut, les bibliotheques de tous les modules sont 
#         prises en compte. Ce parametre est surtout utile en 
#         developpement. Il est donc conseille de conserver la valeur 
#         par defaut (chaine vide). Exemple : 
#           LISTE_LIBRAIRIES="libsaturneBASE.a libsaturneCOGZ.a libsaturneCPLV.a libsaturneELEC_STUB.a libsaturneLAGR.a libsaturneRAYT.a"
#         Ce mot cle est prioritaire sur OPTIMISATION.
#         Une explication est fournie par makehelp (voir MOD=).
#
#       VALGRIND permet de lancer le noyau avec VALGRIND si 
#         ce software de verification de la memoire est disponible (en 
#         paratique sous Linux). Pour l'activer :   
#           VALGRIND="valgrind --tool=memcheck"
#         Dans le cas ou valgrind n'est pas trouve automatiquement dans 
#         le PATH, specifier le chemin d'acces complet.
#
#       ARG_ECS_VERIF permet l'affichage d'informations supplementaires 
#         dans le posttraitement, en particulier les sous-domaines pour 
#         les calculs paralleles et les faces periodiques s'il y en a. 
#         Des informations sur la qualite du maillage sont egalement 
#         produites. Par defaut, on ne post-traite pas ces informations 
#         (ARG_ECS_VERIF=""). Pour les obtenir, indiquer :
#           ARG_ECS_VERIF=" -v"
#
#       ECHOCOMM permet de faire afficher les echanges enveloppe noyau 
#         syrthes. Utile uniquement en cas de probleme de communication. 
#         Si on souhaite activer cette possibilite, on affecte 
#         une valeur entiere strictement positive a ECHOCOMM. A chaque 
#         communication, on affichera les ECHOCOMM premiers et derniers 
#         elements du message (caracteres, entieres, reels).
#         Par defaut, on conserve la chaine vide. 
#         Exemple d'activation raisonnable : 
#           ECHOCOMM="10"
#
#                    -------------------------------
#
#
#
#                 NE PAS LAISSER DE BLANCS (c'est un script)
#
#
#                    -------------------------------
#
ECS_GRD_CDG_CEL_SOM=1
export ECS_GRD_CDG_CEL_SOM
#
IFOENV=1
LONGIA=2000000
LONGRA=10000000
#
TERM=xterm
export TERM
#
VERSION=cs11
#
ETUDE=HERCULE
CAS=DIPH
MAILLAGE="avecpointe.des"
COMMANDE_RC=
COMMANDE_DF=
COMMANDE_PERIO=
COMMANDE_SYRTHES=
DONNEES_THERMOCHIMIE=
#
NOMBRE_DE_PROCESSEURS=
LISTE_PROCESSEURS=
#
FICHIERS_DONNEES_UTILISATEUR=""
FICHIERS_RESULTATS_UTILISATEUR="AXE Z003 Z080 Z160 Z240 Z320 Z420\
                               P003 P080 P160 P240 P320 P420"
#
OPTIMISATION=
LISTE_LIBRAIRIES=
VALGRIND=
#
ARG_ECS_VERIF=""
ECHOCOMM=""
#
listing=listing
resume=resume
REPBASE=/home/prevalcs/Valid_1.1.1/HERCULE/DIPH
DATA=$REPBASE/DATA
RESU=$REPBASE/RESU
FORT=$REPBASE/FORT
EXEC=$REPBASE/SCRIPTS
SUITE_AMONT=$REPBASE/../MONO/RESU/SUITE.05181645
REPMAIL=$REPBASE/../MAILLAGE
#
# Les variables suivantes ne sont utiles que dans les cas couples avec SYRTHES
#  DATA_SYR : repertoire ou trouver syrthes.env 
#  FORT_SYR : repertoire ou trouver les fichiers utilisateurs eventuels
DATA_SYR=$REPBASE/DATA_SYR
FORT_SYR=$REPBASE/FORT_SYR
#
########################################################################
########################################################################
#
#   Version
#     Adresse de la bibliotheque du noyau    
CS_HOME=/home/adm_sc/Lib_SC/V1.1.1
#
#     Adresse de l'enveloppe 
#       sur station
ECS=/home/admesc/ECS/V1.1.1/bin/ecs
#
#     Adresse de Syrthes pour couplage
#       sur station
SYRTHES=/home/admesc/Syrthes/syr_cs/V1.0.1
#
#########################################################################
#
#
# Determination automatique de IFOENV : on aura 
#   IFOENV = 2 si Couplage SYRTHES sauf si IFOENV = 3
#   IFOENV = 3 si sockets (Couplage SYRTHES avec Saturne sur plusieurs 
#                          procs de Scali) 
#  
#
N_COUPLAGE_SYRTHES=0
N_COUPLAGE_SYRTHES=`echo $COMMANDE_SYRTHES | grep -c syrthes`
if [ $N_COUPLAGE_SYRTHES = 0 ] ; then 
  COUPLAGE_SYRTHES=non
else
  COUPLAGE_SYRTHES=oui
fi
#
if [ $COUPLAGE_SYRTHES = oui ] ; then 
  IFOENV=2
# 
  if [ "$NOM_ARCH" = "Linux_Scali" ] ; then 
     if [ ! -z  "${NOMBRE_DE_PROCESSEURS}" ] ; then
       IFOENV=3
     fi 
  fi
fi

#
########################################################################
#
# Definition des parametres d'execution
#
#   Variables generales
THISSCRIPT=`pwd`/$0
USER=`whoami`
DATE=`date '+%m%d%H%M'`
EXE=$VERSION.exe
EXE_SYR=syrthes
#
#   Repertoire d'execution (accessible depuis tous les procs)
RUN=$HOME/tmp_Saturne/$ETUDE.$CAS.$DATE
#
#   Pour les communications par pipe, le montage nfs des linux 
#     exigeait a un moment donne d'etre sur un repertoire local
#     pour les communications par pipe. Ce n'est plus le cas. 
#     En cas de pb on pourrait revenir a 
#     if [ $IFOENV = 2 ] ; then 
#       RUN=/tmp/$USER/$ETUDE.$CAS.$DATE
#     fi
#
RUNB=`dirname $RUN`
if [ ! -d $RUNB ] ; then
  mkdir $RUNB 
fi
mkdir $RUN || exit
ln -s /dev/null $RUN/core
cd $RUN
#
# on recopie le lance des que l'on est dans le repertoire de travail
cp $THISSCRIPT  $RESU/`basename $THISSCRIPT`.$DATE
#
########################################################################
#
# Parallelisme (je force a plus de 1 processeur, pour eviter les pbs de
#    tests)
#
#   si on demande plusieurs processeurs
#
if [ ! -z  "${NOMBRE_DE_PROCESSEURS}" ] ; then
  nproc=0
  nproc=$NOMBRE_DE_PROCESSEURS
  if [ $nproc -gt 1 ] ; then 
    echo Calcul en parallele sur $NOMBRE_DE_PROCESSEURS processeurs
  else
    echo
    echo
    echo " NOMBRE_DE_PROCESSEURS = $NOMBRE_DE_PROCESSEURS "
    echo " NOMBRE_DE_PROCESSEURS doit etre vide ou entier strictement superieur a 1 "
    echo
    exit
  fi
  if [ $IFOENV = 0 ] ; then 
    echo
    echo
    echo " Calcul en parallele impossible avec IFOENV = $IFOENV "
    echo " Utiliser IFOENV = 1 "
    echo
    exit
  fi 
  if [ $IFOENV = 2 ] ; then 
    if [ ! -z "$LISTE_PROCESSEURS" ] ; then 
      echo
      echo
      echo " Attention, avec IFOENV = $IFOENV, les transmissions  "
      echo "   enveloppe-noyau se font par tubes (pipes).         "
      echo " Ici, plusieurs machines ont ete selectionnees pour   "
      echo "   realiser le calcul en parallele :                  "
      echo "   $LISTE_PROCESSEURS                                 "
      echo " Les pipes ne traversent pas le reseau et le calcul   "
      echo "   risque de ne pas pouvoir aboutir.                  "
      echo " Utiliser IFOENV = 1                                  "
      echo
      exit
    fi 
  fi 
#
# Parametres 
#
#
#  ARG_ECS_VERIF=" -v" permet en particulier de voir les ss domaines  
#             lors des calculs paralleles
#             on peut aussi le faire avec Syrthes, maintenant
#
  if [ "$NOM_ARCH" = "Linux_Scali" ] ; then 
    LAMBOOT=""
    MPIRUN="mpirun -np ${NOMBRE_DE_PROCESSEURS}"
    ARG_ECS_PAR=" -p ${NOMBRE_DE_PROCESSEURS}"
    ARG_CS_PAR=" -p ${NOMBRE_DE_PROCESSEURS}"
    WIPE=""
    BHOSTS=""
    BHOSTSOPT=""
    MYAPP=""  
  else 
    HOMELAM="/home/admesc/opt/lam-6.5.9/arch/`uname`/bin"
    if [ -d "$HOMELAM" ] ; then 
      LAMBOOT="$HOMELAM/lamboot"
      WIPE="$HOMELAM/wipe"
      MPIRUN="$HOMELAM/mpirun -np ${NOMBRE_DE_PROCESSEURS}" 
    else
      LAMBOOT="lamboot"
      WIPE="wipe"
      MPIRUN="mpirun -np ${NOMBRE_DE_PROCESSEURS}" 
    fi
    ARG_ECS_PAR=" -p ${NOMBRE_DE_PROCESSEURS}"
    ARG_CS_PAR=" -p ${NOMBRE_DE_PROCESSEURS}"
    BHOSTS="mybhosts"
    BHOSTSOPT="-v"
    MYAPP="myapp"
  fi
#
#   si on ne demande pas plusieurs processeurs
#
else
#
#  ARG_ECS_VERIF=" -v" permet en particulier de voir les faces periodiques
#  if [ ! -z "$COMMANDE_PERIO" ] ; then 
#    ARG_ECS_VERIF=" -v"
#  else
#    ARG_ECS_VERIF=
#  fi
#
  if [ "$NOM_ARCH" = "Linux_Scali" ] ; then 
    MPIRUN="mpirun -np 1"
  else
    MPIRUN=""
  fi
  LISTE_PROCESSEURS=""   
  LAMBOOT=""
  ARG_ECS_PAR=""
  ARG_CS_PAR=""
  WIPE=""
  BHOSTS=""
  BHOSTSOPT=""
  MYAPP=""
fi
#
if [ ! -z "$LISTE_PROCESSEURS" ] ; then
  localproc=`uname -a | awk '{print $2}'`
  echo $LISTE_PROCESSEURS | grep -q $localproc || LISTE_PROCESSEURS="$localproc & $LISTE_PROCESSEURS"
  echo $LISTE_PROCESSEURS | awk  -F\& '{ for (ii = 1; ii < NF+1; ++ii) print $ii }' >> $RUN/$BHOSTS
else
  BHOSTS=""
  BHOSTSOPT=""
fi
# 
########################################################################
# Communications
#
# Definition des pipes
if [ $IFOENV = 2 ] ; then 
  TUBEECS="-tube"
else
  TUBEECS=""
fi
# Definition des sockets
if [ $IFOENV = 3 ] ; then 
  SOCKETNOY="-mc socket"
  SOCKETSYR="-comm-socket"
  SOCKETECS="-socket"
else
  SOCKETNOY=""
  SOCKETSYR=""
  SOCKETECS=""
fi
# En prevision des echo comm si probleme
if [ ! -z "$ECHOCOMM" ] ; then 
  ECHOCOMMNB="$ECHOCOMM"
  ECHOCOMMECS="-echo-comm $ECHOCOMMNB"
  ECHOCOMMSYR="-echo-comm $ECHOCOMMNB"
  ECHOCOMMNOY="--echo-comm $ECHOCOMMNB"
else
  ECHOCOMMNB=""
  ECHOCOMMECS=""
  ECHOCOMMSYR=""
  ECHOCOMMNOY=""
fi
########################################################################
# Message d'accueil 
#
echo ' '
echo '                       Execution de Code_Saturne '
echo '                       ************************* '
echo ' '
echo ' Repertoire de travail (penser a le purger periodiquement) : ' 
echo '    ' $RUN
#
########################################################################

# Fonction de reperage d'un sous programme utilisateur
#  pour le moment, on fait simple 
#   (on pourrait verifier que uslag2 contient bien uslag2 ou encore 
#   qu'il n'est pas bidon ...) 
presence () {

  presence_sspgm=$1

  if [ ! -f "${presence_sspgm}" ] ; then
    presence_PRESENT="non"
  else
    presence_PRESENT="oui"
  fi
  echo ${presence_PRESENT} 
}
#
########################################################################
#
# Compilation et edition des liens
#
# Remarque : on en profite pour reperer la presence de certains 
#            sous-programmes utilisateurs.  
#      En effet, pour le module Lagrangien 
#        le sous-programme uslag2 est toujours present quand le module 
#        utilise ; or, si le module est utilise, il faut passer les noeuds 
#        (ecs -n) et rapatrier les resultats.
#
#
if [ "$CS_HOME" = "" ]; then
   echo
   echo "WARNING: la variable CS_HOME n est pas positionnee"
   echo
   exit
else
  echo
  echo ' Version noyau :      ' $CS_HOME
  echo ' Version enveloppe :  ' $ECS
fi

source_cas=$FORT

if [ -f compil.log ]
then
  rm -f compil.log
fi

echo
echo  "  *****************************************************************************"
echo  "   Compilation des sous-programmes utilisateur et edition de liens Code_Saturne"
echo  "  *****************************************************************************"

# Recopie des sources utilisateur 
#  (pas de liens : on recopie le repertoire ensuite)
cur_dir=`pwd`
mkdir fort_saturne
cd fort_saturne
  for fich in ${source_cas}/*.[F,c,h] ; do 
    if [ -f $fich ] ; then
      cp ${fich} .
    fi
  done

# Detection de la presence de modules 

# Standard
  USCLIM_PRESENT=`presence "usclim.F"`

# Coupes
  USLFAC_PRESENT=`presence "uslfac.F"`

# Lagrangien
  USLAG2_PRESENT=`presence "uslag2.F"`

# Rayonnement
  USRAY2_PRESENT=`presence "usray2.F"`

# Charbon pulverise
  USCPCL_PRESENT=`presence "uscpcl.F"`

# Combustion gaz chimie 3 points
  USD3PC_PRESENT=`presence "usd3pc.F"`

# Combustion gaz EBU
  USEBUC_PRESENT=`presence "usebuc.F"`

# Electrique
  USELCL_PRESENT=`presence "uselcl.F"`

# Tests de compatibilite

  if [ "${USLFAC_PRESENT}" = "oui" ] ; then
    if [ $IFOENV = 0 ] ; then
      echo ' '
      echo ' -- ERREUR -- '
      echo ' Lorsque uslfac est present, on souhaite generer des   '
      echo '  coupes : il faut utiliser le module Enveloppe avec   '
      echo '  IFOENV non nul dans le lanceur                       '
      echo ' '
	exit
    fi
  fi
  if [ "${USCPCL_PRESENT}" = "oui" ] ; then
    if [ "${USCLIM_PRESENT}" = "oui" ] ; then
      echo ' '
      echo ' -- ERREUR -- '
      echo ' Lorsque uscpcl est complete, usclim ne doit pas l etre'
      echo '  (modele combustion charbon pulverise)                '
      echo '  Les conditions aux limites sont fournies dans uscpcl.'
      echo ' '
	exit
    fi
  fi
  if [ "${USD3PC_PRESENT}" = "oui" ] ; then
    if [ "${USCLIM_PRESENT}" = "oui" ] ; then
      echo ' '
      echo ' -- ERREUR -- '
      echo ' Lorsque usd3pc est complete, usclim ne doit pas l etre'
      echo '  (modele combustion charbon pulverise)                '
      echo '  Les conditions aux limites sont fournies dans usd3pc.'
      echo ' '
	exit
    fi
  fi
  if [ "${USEBUC_PRESENT}" = "oui" ] ; then
    if [ "${USCLIM_PRESENT}" = "oui" ] ; then
      echo ' '
      echo ' -- ERREUR -- '
      echo ' Lorsque usebuc est complete, usclim ne doit pas l etre'
      echo '  (modele combustion charbon pulverise)                '
      echo '  Les conditions aux limites sont fournies dans usebuc.'
      echo ' '
	exit
    fi
  fi
  if [ "${USELCL_PRESENT}" = "oui" ] ; then
    if [ "${USCLIM_PRESENT}" = "oui" ] ; then
      echo ' '
      echo ' -- ERREUR -- '
      echo ' Lorsque uselcl est complete, usclim ne doit pas l etre'
      echo '  (modele electrique)                                  '
      echo '  Les conditions aux limites sont fournies dans uselcl.'
      echo ' '
	exit
    fi
  fi

# Traduction 
  if [ "${USLAG2_PRESENT}" = "oui" ] ; then
    LAGRANGIEN=oui
    echo ' '
    echo ' Utilisation du module lagrangien '  
    echo ' '
  else
    LAGRANGIEN=non
  fi
  if [ "${USRAY2_PRESENT}" = "oui" ] ; then
    RAYONNEMENT=oui
    echo ' '
    echo ' Utilisation du module rayonnement '  
    echo ' '
  else
    RAYONNEMENT=non
  fi
  COMBUSTION=non
  if [ "${USCPCL_PRESENT}" = "oui" ] ; then
    COMBUSTION=oui
    COMBUSTION_CPP=oui
    echo ' '
    echo ' Utilisation du module combustion charbon pulverise '  
    echo ' '
  else
    COMBUSTION_CPP=non
  fi
  if [ "${USD3PC_PRESENT}" = "oui" ] ; then
    COMBUSTION=oui
    COMBUSTION_C3P=oui
    echo ' '
    echo ' Utilisation du module combustion chimie trois points '  
    echo ' '
  else
    COMBUSTION_C3P=non
  fi
  if [ "${USEBUC_PRESENT}" = "oui" ] ; then
    COMBUSTION=oui
    COMBUSTION_EBU=oui
    echo ' '
    echo ' Utilisation du module combustion EBU '  
    echo ' '
  else
    COMBUSTION_EBU=non
  fi
  if [ "${USELCL_PRESENT}" = "oui" ] ; then
    ELECTRIQUE=oui
    echo ' '
    echo ' Utilisation du module electrique '  
    echo ' '
  else
    ELECTRIQUE=non
  fi

# Pas de lagrangien en parallele
  if [ "${LAGRANGIEN}" = "oui" ] ; then 
    if [ ! -z "${NOMBRE_DE_PROCESSEURS}" ] ; then 
      echo ' '
      echo ' -- ERREUR -- '
      echo ' Le mode parallele est incompatible avec le module Lagrangien'
      echo '  dans la version courante.                          '
      echo ' '
	exit      
    fi
  fi

# Extraction du main sur HP (link avec f90) sauf s'il existe deja
  if [ "${NOM_ARCH}" = "HP_UX" ] ; then 
    cheminlib=${CS_HOME}/lib/${NOM_ARCH}
    main=cs_main
    mainc=cs_main.c
    maino=cs_main.o
    if [ ! -f "$mainc" ] ; then 
      libsaturneBASE=libsaturneBASE
      if [ ! -z  "${LISTE_LIBRAIRIES}" ] ; then 
        for fich in ${LISTE_LIBRAIRIES} ; do 
          if [ `echo ${fich} | grep ${libsaturneBASE}` ] ; then 
            ar -xv $cheminlib/$fich $maino
          fi
        done 
      elif [ ! -z "${OPTIMISATION}" ] ; then 
        ar -xv $cheminlib/${libsaturneBASE}${OPTIMISATION}.a  $maino
      else
        ar -xv $cheminlib/${libsaturneBASE}.a  $maino
      fi 
    fi 
  fi

# Compilation
  ln -s ${CS_HOME}/bin/Makefile .
  if   [ ! -z "${LISTE_LIBRAIRIES}" -a ! -z "${OPTIMISATION}" ] ; then 
    make saturne OPT="${OPTIMISATION}" LIB="${LISTE_LIBRAIRIES}" 2>>$cur_dir/compil.log 1>&2
  elif [ ! -z "${LISTE_LIBRAIRIES}" ] ; then 
    make saturne LIB="${LISTE_LIBRAIRIES}" 2>>$cur_dir/compil.log 1>&2
  elif [ ! -z "${OPTIMISATION}"     ] ; then 
    make saturne OPT="${OPTIMISATION}"     2>>$cur_dir/compil.log 1>&2
  else
    make saturne                           2>>$cur_dir/compil.log 1>&2
  fi 
  if [ $? -ne 0 ]
  then
    cp $cur_dir/compil.log $RESU/compil.log.$DATE
    echo ERREUR DE COMPILATION OU D\'EDITION DE LIENS
    rm -f *.o
    exit
  else
    cp $cur_dir/compil.log $RESU/compil.log.$DATE
  fi

# Nettoyage
  make clean
  rm -f Makefile
  mv $EXE ${cur_dir}/
  cd ${cur_dir}


if [ $COUPLAGE_SYRTHES = oui ] ; then 

  echo
  echo  "  *****************************************************************************"
  echo  "    Compilation des sous-programmes utilisateur et edition de liens SYRTHES    "
  echo  "  *****************************************************************************"

  
  cur_dir=`pwd`
  mkdir fort_syr 
  cd fort_syr
  for fich in $FORT_SYR/*.[F,c,h] ; do 
    cp ${fich} .
  done
  ln -s $SYRTHES/bin/Makefile .
  make syrthes NOM_ARCH=${NOM_ARCH} 2>>$cur_dir/compil.log 1>&2
  if [ $? -ne 0 ]
  then
    cp $cur_dir/compil.log $RESU/compil.log.$DATE
    echo ERREUR DE COMPILATION OU D\'EDITION DE LIENS
    rm -f *.o
    exit
  else
    cp $cur_dir/compil.log $RESU/compil.log.$DATE
  fi
  make clean
  rm -f Makefile
  mv syrthes $cur_dir/
  cd $cur_dir
  
fi

#
#
########################################################################
#
# Mise en place des donnees  
#
echo
echo  "  ********************************************"
echo  "             Preparation du calcul            "
echo  "  ********************************************"
echo 
echo  " Maillage : "                                         >> $listing
if [ $IFOENV = 0 ]
then
  echo ln -s $REPMAIL/$MAILLAGE geomet                       >> $listing
       ls -altr $REPMAIL/$MAILLAGE                           >> $listing
  ln -s $REPMAIL/$MAILLAGE geomet || exit
else
  for var in $MAILLAGE ; do
    echo ln -s $REPMAIL/$var $var                            >> $listing
         ls -altr $REPMAIL/$var                              >> $listing
    ln -s $REPMAIL/$var $var || exit
  done
fi
#
for var in ${SUITE_AMONT}/* ; do 
  if [ -f $var ] ; then 
    varb=`basename $var`
    if   [ $varb = suiava ] ; then 
      vara=suiamo
    elif [ $varb = suiavx ] ; then 
      vara=suiamx
    elif [ $varb = rayava ] ; then 
      vara=rayamo
    elif [ $varb = lagava ] ; then 
      vara=lagamo
    elif [ $varb = lasava ] ; then 
      vara=lasamo
    else
      vara=$varb
    fi
    ln -s $var $vara
  fi
done
#
if [ "${COMBUSTION}" = "oui" -o "${ELECTRIQUE}" = "oui" ] ; then 
  var=$DATA/$DONNEES_THERMOCHIMIE
  if [ -f $var ] ; then 
    cp $var dp_tch
# recopie pour avoir le bon nom a la sauvegarde
    if [ "$DONNEES_THERMOCHIMIE" != "dp_tch" ] ; then 
      cp dp_tch $DONNEES_THERMOCHIMIE
    fi
  else
    echo ' ' 
    echo ' -- ERREUR -- ' 
    echo ' Le fichier de donnees thermochimie ' $var
    echo '   n est pas accessible ' 
    exit
  fi    
  if [ "${COMBUSTION}" = "oui" ] ; then 
    cp $CS_HOME/data/thch/JANAF JANAF
  fi
fi
#
if [ $COUPLAGE_SYRTHES = oui ] ; then 
  cp $DATA_SYR/syrthes.env  .
fi
#
if [ ! -z "$FICHIERS_DONNEES_UTILISATEUR" ] ; then 
  for fich in $FICHIERS_DONNEES_UTILISATEUR ; do 
    cp $DATA/$fich .
  done
fi
#
########################################################################
# Temps limite pour Cluster (je le fais ici pour laisser le temps a PBS
#   de se rendre compte que ca a demarre)
#
if [ $NOM_ARCH = Linux_Scali ] ; then 
  CS_MAXTIME=`qstat -r $PBS_JOBID | grep $PBS_JOBID | sed -e's/ \{1,\}/ /g' | cut -d ' ' -f 9`
  export CS_MAXTIME   
fi
#
########################################################################
#
# Resume : debut
#
echo '========================================================'>>$resume
echo '    DATE DE DEBUT   : ' $DATE                            >>$resume
echo '  ----------------------------------------------------'  >>$resume
echo '    CS_HOME         : ' $CS_HOME                         >>$resume
echo '    ECS             : ' $ECS                             >>$resume
echo '    ------------------------------------------------  '  >>$resume
cat  $CS_HOME/bin/cs_profile                                   >>$resume
echo '  ----------------------------------------------------'  >>$resume
echo '    UTILISATEUR     : ' $USER                            >>$resume
echo '    ARCHITECTURE    : ' $NOM_ARCH                        >>$resume
echo '========================================================'>>$resume
echo '    MACHINE         : '                                  >>$resume
     uname -a                                                  >>$resume
if [ -z "$NOMBRE_DE_PROCESSEURS" ] ; then 
  echo '    N PROCS         : ' 1                              >>$resume
else
  echo '    N PROCS         : ' $NOMBRE_DE_PROCESSEURS         >>$resume
fi
if [ -z "$LISTE_PROCESSEURS" ] ; then 
  echo '    PROCESSEURS     : ' par defaut                     >>$resume
else
  echo '    PROCESSEURS     : ' $NOMBRE_DE_PROCESSEURS         >>$resume
fi
echo '========================================================'>>$resume
echo '    COMPILATEUR     : '                                  >>$resume
echo '  -----------------------------------------------------' >>$resume
if [ $NOM_ARCH = HP_UX_10        ] ; then 
  what `which f77`                                             >>$resume
  what `which cc`                                              >>$resume
  /usr/sbin/swlist 2>/dev/null |  grep -e 'HP C' -e 'HP FORTRAN' -e OS >>$resume
elif [ $NOM_ARCH = HP_UX         ] ; then 
  what `which f90`                                             >>$resume
  what `which cc`                                              >>$resume
  bidon=bidon_pour_avoir_la_version_du_compilateur
  bidonc=$bidon.c
  if [ -f "$bidonc" ] ; then
    bidoncexiste=1
  else
    bidoncexiste=0
  fi
  if [ "$bidoncexiste" = "0" ] ; then   
    touch $bidonc
  fi
  cc -V $bidonc 2>&1 | grep -v $bidon|grep -v main | grep -v Unsatisfied >>$resume
  rm $bidon.o a.out
  if [ "$bidoncexiste" = "0" ] ; then 
    rm $bidonc 
  fi
elif [ $NOM_ARCH = IRIX64        ] ; then 
  echo f77 -version                                            >>$resume
  f77 -version                                                 >>$resume 2>&1
  echo cc  -version                                            >>$resume
  cc  -version                                                 >>$resume 2>&1
  what `which f77`                                             >>$resume
  what `which cc`                                              >>$resume
elif [ $NOM_ARCH = Linux -o  $NOM_ARCH = Linux_Scali ] ; then 
  g77 -v 2>&1 |grep "g77 version"                              >>$resume
  cc -v  2>&1 |grep "gcc version"                              >>$resume
elif [ $NOM_ARCH = SunOS         ] ; then 
  what `which f77`                                             >>$resume
  what `which cc`                                              >>$resume
elif [ $NOM_ARCH = UNIX_System_V ] ; then 
  frt -V  2>&1 |grep "Driver"                                  >>$resume
  cc -V  2>&1 |grep "Driver"                                   >>$resume
elif [ $NOM_ARCH = OSF1 ] ; then 
  f90 -version                                                 >>$resume 2>&1
  cc -V                                                        >>$resume
else
  echo ' Le numero de version des compilateurs ne peut etre '  >>$resume
  echo '   determine automatiquement sur l architecture ' $NOM_ARCH >>$resume
fi
echo '========================================================'>>$resume
echo '  ----------------------------------------------------'  >>$resume
echo '    CAS             : ' $CAS                             >>$resume
echo '      CONFIG.       : ' $CONF                            >>$resume
echo '        DATA        : ' $DATA                            >>$resume
echo '        FORT        : ' $FORT                            >>$resume
echo '        RESU        : ' $RESU                            >>$resume
echo '  ----------------------------------------------------'  >>$resume
echo '    REP. RUN        : ' $RUN                             >>$resume
echo '  ----------------------------------------------------'  >>$resume
echo '    EXECUTABLE      : ' $EXE                             >>$resume
echo '      BIB           : ' $BIB                             >>$resume
echo '      COMPILATEUR f : ' $COMPF                           >>$resume
echo '      COMPILATEUR c : ' $COMPC                           >>$resume
echo '      OPTIONS     f : ' $OPTCOMPF1                       >>$resume
echo '  ----------------------------------------------------'  >>$resume
#
# Execution 
echo
echo  "  ********************************************"
echo  "                    Execution                 "
echo  "  ********************************************"
echo 
#
ERROR=$RUN/error
erreur()
{
echo ERREUR $1 >> $ERROR
}
#
# En lagrangien et en rayonnement, on a besoin des noeuds
if   [ "${LAGRANGIEN}" = "oui" ] ; then 
  COMMANDE_NOEUDS="-n"
elif [ "${RAYONNEMENT}" = "oui" ] ; then 
  COMMANDE_NOEUDS="-n"
else
  COMMANDE_NOEUDS=""
fi
#
# Creation des pipes si besoin
if [ $IFOENV = 2 ] ; then
#
  if [ ! -z "${NOMBRE_DE_PROCESSEURS}" ] ; then 
    nproc=0
    nproc=$NOMBRE_DE_PROCESSEURS
    num=1
    while [ $num -le $nproc ] ; do 
      numf=`echo $num | awk '{printf "%4.4i\n", $1}'`
      for fich in solveur_n${numf}_vers_enveloppe enveloppe_vers_solveur_n$numf ; do
        if [ -f $fich ] ; then
          rm $fich
        fi
        mkfifo $fich
      done
      (( num = num + 1 ))
    done
  else
    for fich in solveur_vers_enveloppe enveloppe_vers_solveur ; do
      if [ -f $fich ] ; then 
        rm $fich
      fi
      mkfifo $fich
    done
  fi
#
  if [ $COUPLAGE_SYRTHES = oui ] ; then 

    for fich in syrthes_vers_enveloppe.0001 syrthes_vers_enveloppe \
                enveloppe_vers_syrthes.0001 enveloppe_vers_syrthes ; do 
      if [ -f $fich ] ; then
        rm $fich
      fi
    done
 
    mkfifo   syrthes_vers_enveloppe.0001
    mkfifo   enveloppe_vers_syrthes.0001

  fi
#
# Si sockets, on doit adapter la COMMANDE_SYRTHES 
#   (on ajoute -socket apres -syrthes)
elif [ $IFOENV = 3 ] ; then 
  cmdsyr=""
  if [ ! -z "$COMMANDE_SYRTHES" ] ; then 
    for var in $COMMANDE_SYRTHES ; do 
      if [ "$var" = "-syrthes" -o "$var" = "-syr" ] ; then 
        cmdsyr="$cmdsyr $var -socket"
      else 
        cmdsyr="$cmdsyr $var" 
      fi 
    done
    COMMANDE_SYRTHES="$cmdsyr"
  fi
fi
#
if [ $IFOENV = 2 -o $IFOENV = 3 ] ; then
#

#
# Lancement de l'enveloppe
  $ECS $ARG_ECS_PAR $ARG_ECS_VERIF -maillage $MAILLAGE -cas $CAS \
       $COMMANDE_NOEUDS \
       $COMMANDE_SYRTHES \
       $ECHOCOMMECS \
       -resultat solveur*_vers_enveloppe \
       $COMMANDE_PERIO \
       $COMMANDE_RC $COMMANDE_DF $TUBEECS $SOCKETECS > listenv 2>&1 &
#
# Dans le cas des sockets, il faut recuperer la machine et le port
#   dans le listenv ; on utilise un sleep ; on evite le while qui 
#   pourrait attendre eternellement
  if [ $IFOENV = 3 ] ; then 
    sleep 2 
    MACHPORT=""
    MACHPORT=`grep 'Communication possible sur' listenv|sed -e "s/Communication possible sur //g"|sed -e "s/, port /:/g"`
    SOCKETSYR="$SOCKETSYR $MACHPORT"
    SOCKETNOY="$SOCKETNOY $MACHPORT" 
  fi
#
#
# Lancement de syrthes
  if [ $COUPLAGE_SYRTHES = oui ] ; then
    ./$EXE_SYR $SOCKETSYR $ECHOCOMMSYR > listsyr 2>&1 &
  fi
#
# Lancement de saturne
  $LAMBOOT $BHOSTSOPT $BHOSTS
  localexec=$RUN/localexec
  echo '#!/bin/ksh' > $localexec 
  echo cd $RUN >> $localexec 
  echo "$VALGRIND $RUN/$EXE >> $listing 2>&1 $ARG_CS_PAR -ifoenv 2 $SOCKETNOY "\
                             " $ECHOCOMMNOY -longia $LONGIA -longra $LONGRA " >> $localexec 
  chmod 700 $localexec
  $MPIRUN $localexec || erreur " A L'EXECUTION DU NOYAU "
  $WIPE $BHOSTSOPT $BHOSTS
#
#
elif [ $IFOENV = 1 ] ; then
#
  $ECS $ARG_ECS_PAR $ARG_ECS_VERIF -maillage $MAILLAGE -cas $CAS \
           $COMMANDE_NOEUDS \
           $ECHOCOMMECS \
           $COMMANDE_RC $COMMANDE_DF $COMMANDE_PERIO > listenv.pre 2>&1 \
        || erreur " A L'EXECUTION DE L'ENVELOPPE EN PRE-PROCESSING "
#
  if [ ! -f $ERROR ] ; then 
    $LAMBOOT $BHOSTSOPT $BHOSTS 
    localexec=$RUN/localexec
    echo '#!/bin/ksh' > $localexec 
    echo cd $RUN >> $localexec 
    echo "$VALGRIND $RUN/$EXE >> $listing 2>&1 $ARG_CS_PAR -ifoenv $IFOENV "\
         " $ECHOCOMMNOY -longia $LONGIA -longra $LONGRA "  >> $localexec 
    chmod 700 $localexec
    $MPIRUN $localexec || erreur " A L'EXECUTION DU NOYAU "
    $WIPE $BHOSTSOPT $BHOSTS
  fi
#
  if [ ! -f $ERROR ] ; then 
#  quelle que soit la configuration (meme avec un seul processeur), 
#    il faut traiter la periodicite, les recollements et le decoupage
#    des faces comme pour le pre processing. 
    COMMANDE_RC_POST=$COMMANDE_RC
    COMMANDE_DF_POST=$COMMANDE_DF
    COMMANDE_PERIO_POST=$COMMANDE_PERIO
    $ECS $ARG_ECS_PAR $ARG_ECS_VERIF -maillage $MAILLAGE -cas $CAS \
         $ECHOCOMMECS \
         $COMMANDE_RC_POST $COMMANDE_DF_POST $COMMANDE_PERIO_POST -resultat solveur*_vers_enveloppe* \
         > listenv.post 2>&1 \
        || erreur " A L'EXECUTION DE L'ENVELOPPE EN POST-PROCESSING "
  fi
#
else
#
  $VALGRIND ./$EXE >> $listing 2>&1 -ifoenv $IFOENV \
                         -longia $LONGIA -longra $LONGRA \
        || erreur " A L'EXECUTION DU NOYAU "
#
fi
#
########################################################################
#
# Recuperation des resultats : 
#   on commence par tous les fichiers suite
#   (en cas de pb disque, on a plus de chances de pouvoir 
#    poursuivre le calcul). 
#

SUITE_AVAL=$RESU/SUITE.$DATE
iok=1
mkdir ${SUITE_AVAL} || iok=0
if [ $iok = 1 ] ; then 
  for fich in suiava suiavx rayava lagava* lasava* ; do 
    if [ -f $fich ] ; then 
      cp $fich ${SUITE_AVAL}
    fi
  done
else
  for fich in suiava suiavx rayava lagava* lasava* ; do 
    if [ -f $fich ] ; then 
      cp $fich $RESU/$fich.$DATE
    fi
  done
fi

for fich in $DONNEES_THERMOCHIMIE rubmail list* dessin *.med ${FICHIERS_RESULTATS_UTILISATEUR} ; do 
  if [ -f $fich ] ; then 
    cp $fich $RESU/$fich.$DATE
  fi
done

for fich in *.hst ; do
  if [ -f $fich ] ; then
    if [ ! -d $RESU/HIST.$DATE ] ; then 
      mkdir $RESU/HIST.$DATE
    fi
    cp $fich $RESU/HIST.$DATE
  fi
done
for fich in ush* ; do
  if [ -f $fich ] ; then
    if [ ! -d $RESU/HIST.$DATE ] ; then 
      mkdir $RESU/HIST.$DATE
    fi
    cp $fich $RESU/HIST.$DATE
  fi
done


# Recup du cas ensight 
#   les fichiers bord* sont des sorties rayonnement eventuelles 
#   faites dans le noyau en reponse a un besoin urgent 
#   elles seront revues. 

#   S'il y a des fichiers en vrac, on les regroupe dans CHR.$DATE

for fich in chr.* ; do
  if [ -f $fich ] ; then
    if [ ! -d $RESU/CHR.$DATE ] ; then 
      mkdir $RESU/CHR.$DATE 
    fi
    cp $fich $RESU/CHR.$DATE/.
  fi
done

#   On range le repertoire $cas.ensight dans CHR.ENSIGHT.$DATE
#   On range les autres repertoires $dir (=*.ensight) dans $DIR.$DATE

cas=`echo $CAS |tr "[:upper:]" "[:lower:]"`

for dir in *.ensight ; do
  if [ -d $dir ]
  then

    if [ "$dir" = "$cas.ensight" ]
      then
      DIR=CHR.ENSIGHT
      else
      DIR=`echo $dir |tr "[:lower:]" "[:upper:]"`
      fi
    
      mkdir $RESU/$DIR.$DATE 
      if [ $? -ne 0 ]
      then
      echo Echec a la creation de $RESU/$DIR.$DATE
      else
        for fich in $dir/*  ; do 
          if [ -f $fich ] ; then    
          cp -R ${fich} $RESU/$DIR.$DATE/.
          fi
        done
      fi

  fi
done 

if [ "${RAYONNEMENT}" = "oui" ] ; then 
  for fich in bord* ; do
    if [ -f $fich ] ; then  
      if [ ! -d $RESU/CHR.$DATE ] ; then 
        mkdir $RESU/CHR.$DATE 
      fi
      cp $fich $RESU/CHR.$DATE/.
    fi
  done
fi


if [ "${LAGRANGIEN}" = "oui" ] ; then 
  mkdir $RESU/LAGR.$DATE
  for fich in debug* deplacement* trajectoire* frontiere* ; do 
    if [ -f $fich ] ; then 
      cp $fich $RESU/LAGR.$DATE
    fi
  done
fi

for dir in fort_saturne ; do
  if [ -d $dir ] ; then
    mkdir $RESU/FORT.$DATE
    if [ $? -ne 0 ]
    then
      echo Echec a la creation de $RESU/FORT.$DATE
    else
      for fich in $dir/*.[f,F,c,h] ; do
        if [ -f ${fich} ] ; then 
          cp -R ${fich} $RESU/FORT.$DATE/. 
          fichbase=`basename ${fich}`
          chmod a-w $RESU/FORT.$DATE/${fichbase}
        fi
      done
    fi
  fi
done 
if [ $COUPLAGE_SYRTHES = oui ] ; then 
  for dir in fort_syr ; do
    if [ -d $dir ] ; then
      mkdir $RESU/FORT_SYR.$DATE
      if [ $? -ne 0 ]
      then
        echo Echec a la creation de $RESU/FORT_SYR.$DATE
      else
        for fich in $dir/*.[f,F,c,h] ; do
          if [ -f ${fich} ] ; then 
            cp -R ${fich} $RESU/FORT_SYR.$DATE/.
            fichbase=`basename ${fich}`
            chmod a-w $RESU/FORT_SYR.$DATE/${fichbase}
          fi
        done
      fi
    fi
  done 
fi


#
########################################################################
#
# Resume : fin
#
DATEFIN=`date '+%m%d%H%M'`
echo '    DATE DE FIN     : ' $DATEFIN                         >>$resume
echo '========================================================'>>$resume
#
cp $resume  $RESU/$resume.$DATE
#
########################################################################
#
#
# Fin
#
if [ -f $ERROR ] ; then 
#
  echo
  echo  "  ********************************************"
  cat                        $ERROR
  echo  "  ********************************************"
#
else
#
  echo
  echo  "  ********************************************"
  echo  "             Fin normale du calcul            "
  echo  "  ********************************************"
#
fi
#
########################################################################
#
########################################################################
